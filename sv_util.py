#!/usr/bin/env python3

# A script to process sv generated by CIRCT with emittedLineLength long enough to prevent line wrapping

import os

class module_io_def:
    def __init__(self, iotype: str, width: int, name_indent: int, name: str, annotation: str = ''):
        self.iotype = iotype
        self.width = width
        self.name_indent = name_indent
        self.name = name
        self.annotation = annotation
    @classmethod
    def from_str(cls, linestr: str, last = None):
        iotype = ''
        width = 0
        name_indent = 0
        name = ''
        annotation = ''
        def parse_from_name(linestr: str):
            nonlocal iotype, width, name_indent, name, annotation
            # Find "\t" as split
            tab_pos = linestr.find('\t')
            if tab_pos == -1:
                # No annotation
                name = linestr.replace(',', '')
                annotation = ''
                # no space or tab in the name
                assert(len(name) == len(name.strip()))
                # only one ',' or nothing
                assert(len(linestr) - len(name) <= 1)
            else:
                name = linestr[:tab_pos].replace(',', '')
                assert(linestr[tab_pos:tab_pos+3] == '\t//')
                annotation = linestr[tab_pos+3:]
                linestr = linestr[:tab_pos]
                # no space or tab in the name
                assert(len(name) == len(name.strip()))
                # only one ',' or nothing
                assert(len(linestr) - len(name) <= 1)
        if linestr.startswith('  input'):
            iotype = 'input'
        elif linestr.startswith('  output'):
            iotype = 'output'
        else:
            iotype = last.iotype
            width = last.width
            name_indent = len(linestr) - len(linestr.lstrip())
            assert(linestr[:name_indent] == ' ' * name_indent)
            parse_from_name(linestr.lstrip())
            return module_io_def(iotype, width, name_indent, name, annotation)
        linestr = linestr[8:]
        existing_offset = 8
        if linestr.startswith('[') or linestr.startswith(' ['):
            if linestr[0] == ' ':
                existing_offset += 1
                linestr = linestr[1:]
            width = int(linestr[1:linestr.find(':')])+1
            # find the end of the width
            endpos = linestr.find(']')
            linestr = linestr[endpos+1:]
            existing_offset += endpos+1
            name_indent = len(linestr) - len(linestr.lstrip()) + existing_offset
            linestr = linestr.lstrip()
        else:
            width = 1
            name_indent = len(linestr) - len(linestr.lstrip()) + existing_offset
            linestr = linestr.lstrip()
        parse_from_name(linestr)
        return module_io_def(iotype, width, name_indent, name, annotation)
    def __str__(self, dot: bool = False, ever_output = False, last = None):
        ret = '  '
        if last is None or last.iotype != self.iotype or last.width != self.width:
            ret += ( ('input' + (' ' if ever_output else ''))  if self.iotype == 'input' else 'output')
            ret += ' [{}:0] '.format(self.width-1) if self.width > 1 else ''
        ret += ' ' * max(self.name_indent - len(ret), 0) + self.name
        ret += ',' if not dot else ''
        ret += '\t//' + self.annotation if self.annotation != '' else ''
        return ret
    def rename(self, new_name: str):
        return module_io_def(self.iotype, self.width, self.name_indent, new_name, self.annotation)
    def rename_by_prefix(self, prefix: str):
        return self.rename(prefix + self.name)
    def test():
        clk_line = module_io_def.from_str('  input          clock,\t// src/main/scala/xiangshan/XSTile.scala:91:9')
        rst_line = module_io_def.from_str('                 reset,\t// src/main/scala/xiangshan/XSTile.scala:91:9', clk_line)
        random_line  = module_io_def.from_str('  output [29:0]  auto_l2top_l2cache_tpmeta_source_out_bits_rawData_0,\t// rocket-chip/src/main/scala/diplomacy/LazyModule.scala:366:18', rst_line)
        random_line2 = module_io_def.from_str('                 auto_l2top_l2cache_tpmeta_source_out_bits_rawData_1,\t// rocket-chip/src/main/scala/diplomacy/LazyModule.scala:366:18', random_line)
        assert(clk_line.__str__() == "  input          clock,\t// src/main/scala/xiangshan/XSTile.scala:91:9")
        assert(rst_line.__str__() == '  input          reset,\t// src/main/scala/xiangshan/XSTile.scala:91:9')
        assert(random_line.__str__() == '  output [29:0]  auto_l2top_l2cache_tpmeta_source_out_bits_rawData_0,\t// rocket-chip/src/main/scala/diplomacy/LazyModule.scala:366:18')
        assert(random_line2.__str__() == '  output [29:0]  auto_l2top_l2cache_tpmeta_source_out_bits_rawData_1,\t// rocket-chip/src/main/scala/diplomacy/LazyModule.scala:366:18')

class module_def:
    def __init__(self, module_name: str, annotation: str, io_list: list[module_io_def]):
        self.module_name = module_name
        self.annotation = annotation
        self.io_list = io_list.copy()
    @classmethod
    def from_list_str(cls, linestrs: list[str]):
        linestrs = linestrs.copy()
        module_name = ''
        annotation = ''
        io_list = []
        # parse annotation
        comment_pos = linestrs[0].find('\t//')
        if comment_pos == -1:
            annotation = ''
        else:
            annotation = linestrs[0][comment_pos+3:]
            linestrs[0] = linestrs[0][:comment_pos]
        assert(linestrs[0].endswith('('))
        # parse name
        module_name = linestrs[0][7:-1].strip()
        assert(linestrs[0].startswith('module ' + module_name + '('))
        # parse io_list
        for line_idx in range(1, len(linestrs)-1):
            io_list.append(module_io_def.from_str(linestrs[line_idx], last = (io_list[-1] if len(io_list) > 0 else None)))
        assert(linestrs[-1] == ');')
        return cls(module_name, annotation, io_list)
    def gen_list_str(self):
        head = 'module {}('.format(self.module_name) + (('\t//' + self.annotation) if self.annotation != '' else '')
        io_str = []
        ever_output = False
        for idx in range(len(self.io_list)):
            if self.io_list[idx].iotype == 'output':
                ever_output = True
                break
        for idx in range(len(self.io_list)):
            io_str.append(self.io_list[idx].__str__(dot = idx == len(self.io_list) - 1, ever_output = ever_output ,last = (self.io_list[idx-1] if idx > 0 else None)))
        return [head] + io_str + [');']
    def __str__(self):
        return "\n".join(self.gen_list_str())
    def test():
        str = [
            'module XSCore(	// src/main/scala/xiangshan/XSCore.scala:155:7',
            '  input [1:0]        clock,	// src/main/scala/xiangshan/XSCore.scala:155:7',
            '                     reset	// src/main/scala/xiangshan/XSCore.scala:155:7',
            ');'
        ]
        inst1 = module_def.from_list_str(str)
        assert(inst1.__str__() == '\n'.join(str))

class inst_io_def: 
    def __init__(self, name: str, expr: str, expr_indent: int, annotation: str = ''):
        self.name = name
        self.expr = expr
        self.expr_indent = expr_indent
        self.annotation = annotation
    @classmethod
    def from_str(cls, linestr: str):
        name = ''
        expr = ''
        annotation = ''
        expr_indent = 0
        assert(linestr.startswith('    .'))
        # parse annotation
        comment_pos = linestr.find('\t//')
        if comment_pos == -1:
            annotation = ''
        else:
            annotation = linestr[comment_pos+3:]
            linestr = linestr[:comment_pos]
        # parse expr
        expr_pos_l = linestr.find('(')
        expr_pos_r = linestr.rfind(')')
        expr = linestr[expr_pos_l+1:expr_pos_r]
        expr_indent = expr_pos_l
        # parse io_name
        name = linestr[5:expr_pos_l].strip()
        return cls(name, expr, expr_indent, annotation)
    def __str__(self, dot: bool = False):
        buf  = '    .' + self.name
        buf += ' ' * max(self.expr_indent - len(buf), 0) + "({})".format(self.expr)
        buf += (',' if not dot else '') + (('\t//' + self.annotation) if self.annotation != '' else '')
        return buf
    def test():
        inst1 = inst_io_def.from_str('    .clock                                                         (clock),')
        inst2 = inst_io_def.from_str('    .auto_memBlock_frontendBridge_instr_uncache_out_a_ready        (_l2top_auto_i_mmio_buffer_in_a_ready),	// src/main/scala/xiangshan/XSTile.scala:37:33')
        assert(inst1.__str__() == '    .clock                                                         (clock),')
        assert(inst2.__str__() == '    .auto_memBlock_frontendBridge_instr_uncache_out_a_ready        (_l2top_auto_i_mmio_buffer_in_a_ready),	// src/main/scala/xiangshan/XSTile.scala:37:33')

class inst_def:
    def __init__(self, module_name: str, inst_name: str, annotation: str, io_list: list[inst_io_def]):
        self.module_name = module_name
        self.inst_name = inst_name
        self.annotation = annotation
        self.io_list = io_list.copy()
    @classmethod
    def from_list_str(cls, linestrs: list[str]):
        module_name = ''
        inst_name = ''
        annotation = ''
        io_list = []
        linestrs = linestrs.copy()
        # parse annotation
        comment_pos = linestrs[0].find('\t//')
        if comment_pos == -1:
            annotation = ''
        else:
            annotation = linestrs[0][comment_pos+3:]
            linestrs[0] = linestrs[0][:comment_pos]
        assert(linestrs[0].endswith('('))
        # parse name
        module_name, inst_name = linestrs[0][:-2].strip().split(' ')
        assert(linestrs[0].startswith('  ' + module_name + ' ' + inst_name + ' ('))
        # parse inst_list
        io_list = [ inst_io_def.from_str(linestr) for linestr in linestrs[1:-1] ]
        assert(linestrs[-1] == '  );')
        return cls(module_name, inst_name, annotation, io_list)
    def gen_list_str(self):
        head = '  {} {} ('.format(self.module_name, self.inst_name) + (('\t//' + self.annotation) if self.annotation != '' else '')
        return [head] + [io.__str__(dot = i == len(self.io_list) - 1) for i, io in enumerate(self.io_list)] + ['  );']
    def __str__(self):
        return "\n".join(self.gen_list_str())
    def test():
        str = [
            '  XSTile auto_l2top_auto_i_mmio_buffer (\t// src/main/scala/xiangshan/XSTile.scala:37:33',
            '    .clock                                                         (clock),',
            '    .reset                                                         (reset),',
            '    .auto_memBlock_frontendBridge_instr_uncache_out_a_ready        (_l2top_auto_i_mmio_buffer_in_a_ready)\t// src/main/scala/xiangshan/XSTile.scala:37:33',
            '  );'
        ]
        inst1 = inst_def.from_list_str(str)
        assert(inst1.__str__() == '\n'.join(str))

class module_file:
    def __init__(self, blocks: list):
        self.blocks = blocks.copy()
    @classmethod
    def from_list_str(cls, svlines: list[str]):
        blocks = []
        tmp_buffer = []
        line_idx = 0
        def clear_tmp_buffer():
            nonlocal tmp_buffer
            if len(tmp_buffer) > 0:
                blocks.append(tmp_buffer)
                tmp_buffer = []
        while line_idx < len(svlines):
            line = svlines[line_idx]
            line_idx += 1
            if line.startswith("module"):
                clear_tmp_buffer()
                # find ):
                module_start_pos = line_idx - 1
                module_end_pos = -1
                while line_idx < len(svlines):
                    line_idx += 1
                    if svlines[line_idx-1].startswith(");"):
                        module_end_pos = line_idx-1
                        break
                assert(module_end_pos != -1)
                blocks.append(module_def.from_list_str(svlines[module_start_pos:module_end_pos+1]))
            else:
                # parse token
                if line.startswith("  ") and line[2] != ' ': # token
                    token = line.split()[0]
                    keywords = {'wire', 'always', 'assign', '`endif', 'end', '`ifdef', 'reg', '`define', '`else', '`ifndef'}
                    if token not in keywords: # is inst def
                        assert(token != ");")
                        clear_tmp_buffer()
                        # Find );
                        inst_start_pos = line_idx - 1
                        inst_end_pos = -1
                        while line_idx < len(svlines):
                            if svlines[line_idx].startswith("  );"):
                                inst_end_pos = line_idx
                                line_idx += 1
                                break
                            line_idx += 1
                        assert(inst_end_pos != -1)
                        blocks.append(inst_def.from_list_str(svlines[inst_start_pos:inst_end_pos+1]))
                    else:
                        tmp_buffer.append(line)
                elif line == "endmodule":
                    clear_tmp_buffer()
                    blocks.append(['endmodule'])
                else:
                    tmp_buffer.append(line)
            clear_tmp_buffer()
        return cls(blocks)
    def gen_list_str(self):
        return [ "\n".join(block) if type(block) == list else block.__str__() for block in self.blocks]
    def __str__(self):
        return "\n".join(self.gen_list_str())
    def find_inst(self, inst_name: str):
        for block in self.blocks:
            if isinstance(block, inst_def) and block.inst_name == inst_name:
                return block
        return None
    def get_module_def(self):
        for block in self.blocks:
            if isinstance(block, module_def):
                return block
        assert(False)
    def add_io_def(self, io_def: module_io_def):
        for block in self.blocks:
            if isinstance(block, module_def):
                for io in block.io_list:
                    if io.name == io_def.name:
                        return False
                # name check passed
                block.io_list.append(io_def)
                return True
        return False
    def add_assign(self, assign:list[(str, str)]):
        endmodule_idx = self.blocks.index(["endmodule"])
        assert(endmodule_idx != -1)
        for lvalue, rvalue in assign:
            self.blocks.insert(endmodule_idx, "  assign {} = {}; // generated by sv_util.py".format(lvalue, rvalue))
            # It may be O(n**2) but it's fine
            endmodule_idx += 1
    def remove_inst(self, inst_name: str):
        for idx, block in enumerate(self.blocks):
            if isinstance(block, inst_def) and block.inst_name == inst_name:
                self.blocks.pop(idx)
                return
    def test(dir: str):
        for file in os.listdir(dir):
            if file.endswith(".sv"):
                with open("vsrc/" + file, "r") as f:
                    lines = [x.rstrip() for x in f.readlines()]
                    module_file_test = module_file.from_list_str(lines.copy())
                    cnt_module_def = 0
                    cnt_inst_def = 0
                    for block in module_file_test.blocks:
                        if isinstance(block, module_def):
                            cnt_module_def += 1
                        elif isinstance(block, inst_def):
                            cnt_inst_def += 1
                    assert(cnt_module_def <= 1)
                    print("module_def: {}, inst_def: {}".format(cnt_module_def, cnt_inst_def))
                    if module_file_test.__str__() != '\n'.join(lines):
                        print("fail {}".format(file))
                        with open("expect.sv", "w") as f:
                            f.write('\n'.join(lines))
                        with open("output.sv", "w") as f:
                            f.write(module_file_test.__str__())
                        exit(1)

def test():
    module_io_def.test()
    module_def.test()
    inst_io_def.test()
    inst_def.test()
    module_file.test("vsrc")
